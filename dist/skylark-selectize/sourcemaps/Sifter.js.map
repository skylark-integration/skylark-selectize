{"version":3,"sources":["Sifter.js"],"names":["define","langx","cmp","a","b","asciifold","String","getattr","obj","name","nesting","names","split","length","shift","DIACRITICS","c","d","e","f","g","h","i","j","k","l","n","o","p","q","r","s","t","u","v","w","x","y","z","chunk","foreignletters","lookup","hasOwnProperty","substring","charAt","regexp","RegExp","str","replace","foreignletter","toLowerCase","Sifter","items","settings","this","diacritics","prototype","tokenize","query","trim","regex","letter","tokens","words","push","string","iterator","object","callback","isArray","Array","forEach","key","apply","getScoreFunction","search","options","fields","token_count","prepareSearch","field_count","scoreValue","value","token","score","pos","scoreObject","data","sum","conjunction","getSortFunction","self","field","fields_count","multiplier","multipliers","get_field","implicit_score","sort","sort_empty","result","id","unshift","direction","splice","option_fields","extend","option_sort","option_sort_empty","total","fn_sort","fn_score","item","filter","limit","slice"],"mappings":"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","file":"../Sifter.js","sourcesContent":["define([\r\n\t\"skylark-langx/langx\"\r\n],function(langx){\r\n\r\n\tvar escape_regex = function(str) {\r\n\t\treturn (str + '').replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\r\n\t};\r\n\r\n\tvar cmp = function(a, b) {\r\n\t\tif (typeof a === 'number' && typeof b === 'number') {\r\n\t\t\treturn a > b ? 1 : (a < b ? -1 : 0);\r\n\t\t}\r\n\t\ta = asciifold(String(a || ''));\r\n\t\tb = asciifold(String(b || ''));\r\n\t\tif (a > b) return 1;\r\n\t\tif (b > a) return -1;\r\n\t\treturn 0;\r\n\t};\r\n\r\n\t/**\r\n\t * A property getter resolving dot-notation\r\n\t * @param  {Object}  obj     The root object to fetch property on\r\n\t * @param  {String}  name    The optionally dotted property name to fetch\r\n\t * @param  {Boolean} nesting Handle nesting or not\r\n\t * @return {Object}          The resolved property value\r\n\t */\r\n\tvar getattr = function(obj, name, nesting) {\r\n\t    if (!obj || !name) return;\r\n\t    if (!nesting) return obj[name];\r\n\t    var names = name.split(\".\");\r\n\t    while(names.length && (obj = obj[names.shift()]));\r\n\t    return obj;\r\n\t};\r\n\r\n\tvar DIACRITICS = {\r\n\t\t'a': '[aá¸€á¸Ä‚ÄƒÃ‚Ã¢ÇÇÈºâ±¥È¦È§áº áº¡Ã„Ã¤Ã€Ã ÃÃ¡Ä€ÄÃƒÃ£Ã…Ã¥Ä…Ä„ÃƒÄ…Ä„]',\r\n\t\t'b': '[bâ¢Î²Î’Bà¸¿ğŒá›’]',\r\n\t\t'c': '[cÄ†Ä‡ÄˆÄ‰ÄŒÄÄŠÄ‹CÌ„cÌ„Ã‡Ã§á¸ˆá¸‰È»È¼Æ‡ÆˆÉ•á´„ï¼£ï½ƒ]',\r\n\t\t'd': '[dÄÄá¸Šá¸‹á¸á¸‘á¸Œá¸á¸’á¸“á¸á¸ÄÄ‘DÌ¦dÌ¦Æ‰É–ÆŠÉ—Æ‹ÆŒáµ­á¶á¶‘È¡á´…ï¼¤ï½„Ã°]',\r\n\t\t'e': '[eÃ‰Ã©ÃˆÃ¨ÃŠÃªá¸˜á¸™ÄšÄ›Ä”Ä•áº¼áº½á¸šá¸›áººáº»Ä–Ä—Ã‹Ã«Ä’Ä“È¨È©Ä˜Ä™á¶’É†É‡È„È…áº¾áº¿á»€á»á»„á»…á»‚á»ƒá¸œá¸á¸–á¸—á¸”á¸•È†È‡áº¸áº¹á»†á»‡â±¸á´‡ï¼¥ï½…É˜ÇÆÆÎµ]',\r\n\t\t'f': '[fÆ‘Æ’á¸á¸Ÿ]',\r\n\t\t'g': '[gÉ¢â‚²Ç¤Ç¥ÄœÄÄÄŸÄ¢Ä£Æ“É Ä Ä¡]',\r\n\t\t'h': '[hÄ¤Ä¥Ä¦Ä§á¸¨á¸©áº–áº–á¸¤á¸¥á¸¢á¸£É¦Ê°Ç¶Æ•]',\r\n\t\t'i': '[iÃÃ­ÃŒÃ¬Ä¬Ä­ÃÃ®ÇÇÃÃ¯á¸®á¸¯Ä¨Ä©Ä®Ä¯ÄªÄ«á»ˆá»‰ÈˆÈ‰ÈŠÈ‹á»Šá»‹á¸¬á¸­Æ—É¨É¨Ì†áµ»á¶–Ä°iIÄ±Éªï¼©ï½‰]',\r\n\t\t'j': '[jÈ·Ä´ÄµÉˆÉ‰ÊÉŸÊ²]',\r\n\t\t'k': '[kÆ˜Æ™ê€êá¸°á¸±Ç¨Ç©á¸²á¸³á¸´á¸µÎºÏ°â‚­]',\r\n\t\t'l': '[lÅÅ‚Ä½Ä¾Ä»Ä¼Ä¹Äºá¸¶á¸·á¸¸á¸¹á¸¼á¸½á¸ºá¸»Ä¿Å€È½Æšâ± â±¡â±¢É«É¬á¶…É­È´ÊŸï¼¬ï½Œ]',\r\n\t\t'n': '[nÅƒÅ„Ç¸Ç¹Å‡ÅˆÃ‘Ã±á¹„á¹…Å…Å†á¹†á¹‡á¹Šá¹‹á¹ˆá¹‰NÌˆnÌˆÆÉ²È Æáµ°á¶‡É³ÈµÉ´ï¼®ï½ÅŠÅ‹]',\r\n\t\t'o': '[oÃ˜Ã¸Ã–Ã¶Ã“Ã³Ã’Ã²Ã”Ã´Ç‘Ç’ÅÅ‘ÅÅÈ®È¯á»Œá»ÆŸÉµÆ Æ¡á»á»ÅŒÅÃ•ÃµÇªÇ«ÈŒÈÕ•Ö…]',\r\n\t\t'p': '[pá¹”á¹•á¹–á¹—â±£áµ½Æ¤Æ¥áµ±]',\r\n\t\t'q': '[qê–ê—Ê ÉŠÉ‹ê˜ê™qÌƒ]',\r\n\t\t'r': '[rÅ”Å•ÉŒÉÅ˜Å™Å–Å—á¹˜á¹™ÈÈ‘È’È“á¹šá¹›â±¤É½]',\r\n\t\t's': '[sÅšÅ›á¹ á¹¡á¹¢á¹£ê¨ê©ÅœÅÅ Å¡ÅÅŸÈ˜È™SÌˆsÌˆ]',\r\n\t\t't': '[tÅ¤Å¥á¹ªá¹«Å¢Å£á¹¬á¹­Æ®ÊˆÈšÈ›á¹°á¹±á¹®á¹¯Æ¬Æ­]',\r\n\t\t'u': '[uÅ¬Å­É„Ê‰á»¤á»¥ÃœÃ¼ÃšÃºÃ™Ã¹Ã›Ã»Ç“Ç”Å°Å±Å¬Å­Æ¯Æ°á»¦á»§ÅªÅ«Å¨Å©Å²Å³È”È•âˆª]',\r\n\t\t'v': '[vá¹¼á¹½á¹¾á¹¿Æ²Ê‹êêŸâ±±Ê‹]',\r\n\t\t'w': '[wáº‚áºƒáº€áºÅ´Åµáº„áº…áº†áº‡áºˆáº‰]',\r\n\t\t'x': '[xáºŒáºáºŠáº‹Ï‡]',\r\n\t\t'y': '[yÃÃ½á»²á»³Å¶Å·Å¸Ã¿á»¸á»¹áºáºá»´á»µÉÉÆ³Æ´]',\r\n\t\t'z': '[zÅ¹Åºáºáº‘Å½Å¾Å»Å¼áº’áº“áº”áº•ÆµÆ¶]'\r\n\t};\r\n\r\n\tvar asciifold = (function() {\r\n\t\tvar i, n, k, chunk;\r\n\t\tvar foreignletters = '';\r\n\t\tvar lookup = {};\r\n\t\tfor (k in DIACRITICS) {\r\n\t\t\tif (DIACRITICS.hasOwnProperty(k)) {\r\n\t\t\t\tchunk = DIACRITICS[k].substring(2, DIACRITICS[k].length - 1);\r\n\t\t\t\tforeignletters += chunk;\r\n\t\t\t\tfor (i = 0, n = chunk.length; i < n; i++) {\r\n\t\t\t\t\tlookup[chunk.charAt(i)] = k;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar regexp = new RegExp('[' +  foreignletters + ']', 'g');\r\n\t\treturn function(str) {\r\n\t\t\treturn str.replace(regexp, function(foreignletter) {\r\n\t\t\t\treturn lookup[foreignletter];\r\n\t\t\t}).toLowerCase();\r\n\t\t};\r\n\t})();\r\n\r\n\t/**\r\n\t * Textually searches arrays and hashes of objects\r\n\t * by property (or multiple properties). Designed\r\n\t * specifically for autocomplete.\r\n\t *\r\n\t * @constructor\r\n\t * @param {array|object} items\r\n\t * @param {object} items\r\n\t */\r\n\tvar Sifter = function(items, settings) {\r\n\t\tthis.items = items;\r\n\t\tthis.settings = settings || {diacritics: true};\r\n\t};\r\n\r\n\t/**\r\n\t * Splits a search string into an array of individual\r\n\t * regexps to be used to match results.\r\n\t *\r\n\t * @param {string} query\r\n\t * @returns {array}\r\n\t */\r\n\tSifter.prototype.tokenize = function(query) {\r\n\t\tquery = langx.trim(String(query || '').toLowerCase());\r\n\t\tif (!query || !query.length) return [];\r\n\r\n\t\tvar i, n, regex, letter;\r\n\t\tvar tokens = [];\r\n\t\tvar words = query.split(/ +/);\r\n\r\n\t\tfor (i = 0, n = words.length; i < n; i++) {\r\n\t\t\tregex = escape_regex(words[i]);\r\n\t\t\tif (this.settings.diacritics) {\r\n\t\t\t\tfor (letter in DIACRITICS) {\r\n\t\t\t\t\tif (DIACRITICS.hasOwnProperty(letter)) {\r\n\t\t\t\t\t\tregex = regex.replace(new RegExp(letter, 'g'), DIACRITICS[letter]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\ttokens.push({\r\n\t\t\t\tstring : words[i],\r\n\t\t\t\tregex  : new RegExp(regex, 'i')\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn tokens;\r\n\t};\r\n\r\n\t/**\r\n\t * Iterates over arrays and hashes.\r\n\t *\r\n\t * ```\r\n\t * this.iterator(this.items, function(item, id) {\r\n\t *    // invoked for each item\r\n\t * });\r\n\t * ```\r\n\t *\r\n\t * @param {array|object} object\r\n\t */\r\n\tSifter.prototype.iterator = function(object, callback) {\r\n\t\tvar iterator;\r\n\t\tif (langx.isArray(object)) {\r\n\t\t\titerator = Array.prototype.forEach || function(callback) {\r\n\t\t\t\tfor (var i = 0, n = this.length; i < n; i++) {\r\n\t\t\t\t\tcallback(this[i], i, this);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\titerator = function(callback) {\r\n\t\t\t\tfor (var key in this) {\r\n\t\t\t\t\tif (this.hasOwnProperty(key)) {\r\n\t\t\t\t\t\tcallback(this[key], key, this);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\titerator.apply(object, [callback]);\r\n\t};\r\n\r\n\t/**\r\n\t * Returns a function to be used to score individual results.\r\n\t *\r\n\t * Good matches will have a higher score than poor matches.\r\n\t * If an item is not a match, 0 will be returned by the function.\r\n\t *\r\n\t * @param {object|string} search\r\n\t * @param {object} options (optional)\r\n\t * @returns {function}\r\n\t */\r\n\tSifter.prototype.getScoreFunction = function(search, options) {\r\n\t\tvar self, fields, tokens, token_count, nesting;\r\n\r\n\t\tself        = this;\r\n\t\tsearch      = self.prepareSearch(search, options);\r\n\t\ttokens      = search.tokens;\r\n\t\tfields      = search.options.fields;\r\n\t\ttoken_count = tokens.length;\r\n\t\tnesting     = search.options.nesting;\r\n\r\n\t\t/**\r\n\t\t * Calculates how close of a match the\r\n\t\t * given value is against a search token.\r\n\t\t *\r\n\t\t * @param {mixed} value\r\n\t\t * @param {object} token\r\n\t\t * @return {number}\r\n\t\t */\r\n\t\tvar scoreValue = function(value, token) {\r\n\t\t\tvar score, pos;\r\n\r\n\t\t\tif (!value) return 0;\r\n\t\t\tvalue = String(value || '');\r\n\t\t\tpos = value.search(token.regex);\r\n\t\t\tif (pos === -1) return 0;\r\n\t\t\tscore = token.string.length / value.length;\r\n\t\t\tif (pos === 0) score += 0.5;\r\n\t\t\treturn score;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Calculates the score of an object\r\n\t\t * against the search query.\r\n\t\t *\r\n\t\t * @param {object} token\r\n\t\t * @param {object} data\r\n\t\t * @return {number}\r\n\t\t */\r\n\t\tvar scoreObject = (function() {\r\n\t\t\tvar field_count = fields.length;\r\n\t\t\tif (!field_count) {\r\n\t\t\t\treturn function() { return 0; };\r\n\t\t\t}\r\n\t\t\tif (field_count === 1) {\r\n\t\t\t\treturn function(token, data) {\r\n\t\t\t\t\treturn scoreValue(getattr(data, fields[0], nesting), token);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\treturn function(token, data) {\r\n\t\t\t\tfor (var i = 0, sum = 0; i < field_count; i++) {\r\n\t\t\t\t\tsum += scoreValue(getattr(data, fields[i], nesting), token);\r\n\t\t\t\t}\r\n\t\t\t\treturn sum / field_count;\r\n\t\t\t};\r\n\t\t})();\r\n\r\n\t\tif (!token_count) {\r\n\t\t\treturn function() { return 0; };\r\n\t\t}\r\n\t\tif (token_count === 1) {\r\n\t\t\treturn function(data) {\r\n\t\t\t\treturn scoreObject(tokens[0], data);\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tif (search.options.conjunction === 'and') {\r\n\t\t\treturn function(data) {\r\n\t\t\t\tvar score;\r\n\t\t\t\tfor (var i = 0, sum = 0; i < token_count; i++) {\r\n\t\t\t\t\tscore = scoreObject(tokens[i], data);\r\n\t\t\t\t\tif (score <= 0) return 0;\r\n\t\t\t\t\tsum += score;\r\n\t\t\t\t}\r\n\t\t\t\treturn sum / token_count;\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\treturn function(data) {\r\n\t\t\t\tfor (var i = 0, sum = 0; i < token_count; i++) {\r\n\t\t\t\t\tsum += scoreObject(tokens[i], data);\r\n\t\t\t\t}\r\n\t\t\t\treturn sum / token_count;\r\n\t\t\t};\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Returns a function that can be used to compare two\r\n\t * results, for sorting purposes. If no sorting should\r\n\t * be performed, `null` will be returned.\r\n\t *\r\n\t * @param {string|object} search\r\n\t * @param {object} options\r\n\t * @return function(a,b)\r\n\t */\r\n\tSifter.prototype.getSortFunction = function(search, options) {\r\n\t\tvar i, n, self, field, fields, fields_count, multiplier, multipliers, get_field, implicit_score, sort;\r\n\r\n\t\tself   = this;\r\n\t\tsearch = self.prepareSearch(search, options);\r\n\t\tsort   = (!search.query && options.sort_empty) || options.sort;\r\n\r\n\t\t/**\r\n\t\t * Fetches the specified sort field value\r\n\t\t * from a search result item.\r\n\t\t *\r\n\t\t * @param  {string} name\r\n\t\t * @param  {object} result\r\n\t\t * @return {mixed}\r\n\t\t */\r\n\t\tget_field = function(name, result) {\r\n\t\t\tif (name === '$score') return result.score;\r\n\t\t\treturn getattr(self.items[result.id], name, options.nesting);\r\n\t\t};\r\n\r\n\t\t// parse options\r\n\t\tfields = [];\r\n\t\tif (sort) {\r\n\t\t\tfor (i = 0, n = sort.length; i < n; i++) {\r\n\t\t\t\tif (search.query || sort[i].field !== '$score') {\r\n\t\t\t\t\tfields.push(sort[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// the \"$score\" field is implied to be the primary\r\n\t\t// sort field, unless it's manually specified\r\n\t\tif (search.query) {\r\n\t\t\timplicit_score = true;\r\n\t\t\tfor (i = 0, n = fields.length; i < n; i++) {\r\n\t\t\t\tif (fields[i].field === '$score') {\r\n\t\t\t\t\timplicit_score = false;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (implicit_score) {\r\n\t\t\t\tfields.unshift({field: '$score', direction: 'desc'});\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (i = 0, n = fields.length; i < n; i++) {\r\n\t\t\t\tif (fields[i].field === '$score') {\r\n\t\t\t\t\tfields.splice(i, 1);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tmultipliers = [];\r\n\t\tfor (i = 0, n = fields.length; i < n; i++) {\r\n\t\t\tmultipliers.push(fields[i].direction === 'desc' ? -1 : 1);\r\n\t\t}\r\n\r\n\t\t// build function\r\n\t\tfields_count = fields.length;\r\n\t\tif (!fields_count) {\r\n\t\t\treturn null;\r\n\t\t} else if (fields_count === 1) {\r\n\t\t\tfield = fields[0].field;\r\n\t\t\tmultiplier = multipliers[0];\r\n\t\t\treturn function(a, b) {\r\n\t\t\t\treturn multiplier * cmp(\r\n\t\t\t\t\tget_field(field, a),\r\n\t\t\t\t\tget_field(field, b)\r\n\t\t\t\t);\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\treturn function(a, b) {\r\n\t\t\t\tvar i, result, a_value, b_value, field;\r\n\t\t\t\tfor (i = 0; i < fields_count; i++) {\r\n\t\t\t\t\tfield = fields[i].field;\r\n\t\t\t\t\tresult = multipliers[i] * cmp(\r\n\t\t\t\t\t\tget_field(field, a),\r\n\t\t\t\t\t\tget_field(field, b)\r\n\t\t\t\t\t);\r\n\t\t\t\t\tif (result) return result;\r\n\t\t\t\t}\r\n\t\t\t\treturn 0;\r\n\t\t\t};\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Parses a search query and returns an object\r\n\t * with tokens and fields ready to be populated\r\n\t * with results.\r\n\t *\r\n\t * @param {string} query\r\n\t * @param {object} options\r\n\t * @returns {object}\r\n\t */\r\n\tSifter.prototype.prepareSearch = function(query, options) {\r\n\t\tif (typeof query === 'object') return query;\r\n\r\n\t\toptions = langx.extend({}, options);\r\n\r\n\t\tvar option_fields     = options.fields;\r\n\t\tvar option_sort       = options.sort;\r\n\t\tvar option_sort_empty = options.sort_empty;\r\n\r\n\t\tif (option_fields && !langx.isArray(option_fields)) options.fields = [option_fields];\r\n\t\tif (option_sort && !langx.isArray(option_sort)) options.sort = [option_sort];\r\n\t\tif (option_sort_empty && !langx.isArray(option_sort_empty)) options.sort_empty = [option_sort_empty];\r\n\r\n\t\treturn {\r\n\t\t\toptions : options,\r\n\t\t\tquery   : String(query || '').toLowerCase(),\r\n\t\t\ttokens  : this.tokenize(query),\r\n\t\t\ttotal   : 0,\r\n\t\t\titems   : []\r\n\t\t};\r\n\t};\r\n\r\n\t/**\r\n\t * Searches through all items and returns a sorted array of matches.\r\n\t *\r\n\t * The `options` parameter can contain:\r\n\t *\r\n\t *   - fields {string|array}\r\n\t *   - sort {array}\r\n\t *   - score {function}\r\n\t *   - filter {bool}\r\n\t *   - limit {integer}\r\n\t *\r\n\t * Returns an object containing:\r\n\t *\r\n\t *   - options {object}\r\n\t *   - query {string}\r\n\t *   - tokens {array}\r\n\t *   - total {int}\r\n\t *   - items {array}\r\n\t *\r\n\t * @param {string} query\r\n\t * @param {object} options\r\n\t * @returns {object}\r\n\t */\r\n\tSifter.prototype.search = function(query, options) {\r\n\t\tvar self = this, value, score, search, calculateScore;\r\n\t\tvar fn_sort;\r\n\t\tvar fn_score;\r\n\r\n\t\tsearch  = this.prepareSearch(query, options);\r\n\t\toptions = search.options;\r\n\t\tquery   = search.query;\r\n\r\n\t\t// generate result scoring function\r\n\t\tfn_score = options.score || self.getScoreFunction(search);\r\n\r\n\t\t// perform search and sort\r\n\t\tif (query.length) {\r\n\t\t\tself.iterator(self.items, function(item, id) {\r\n\t\t\t\tscore = fn_score(item);\r\n\t\t\t\tif (options.filter === false || score > 0) {\r\n\t\t\t\t\tsearch.items.push({'score': score, 'id': id});\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\tself.iterator(self.items, function(item, id) {\r\n\t\t\t\tsearch.items.push({'score': 1, 'id': id});\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tfn_sort = self.getSortFunction(search, options);\r\n\t\tif (fn_sort) search.items.sort(fn_sort);\r\n\r\n\t\t// apply limits\r\n\t\tsearch.total = search.items.length;\r\n\t\tif (typeof options.limit === 'number') {\r\n\t\t\tsearch.items = search.items.slice(0, options.limit);\r\n\t\t}\r\n\r\n\t\treturn search;\r\n\t};\r\n\t\r\n\treturn Sifter;\r\n})"]}